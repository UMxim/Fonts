from PIL import Image, ImageDraw, ImageFont
import os

def char_to_bitmap(char, font, height):
    # Создаем временное изображение для измерения размера текста
    dummy = Image.new('L', (1, 1))
    draw = ImageDraw.Draw(dummy)
    # Определяем ширину символа
    bbox = draw.textbbox((0, 0), char, font=font)
    width = bbox[2] - bbox[0]
    if width == 0:
        width = height // 2  # минимальная ширина для пробела

    # Создаем изображение под размер символа
    img = Image.new('L', (width, height), color=0)
    draw = ImageDraw.Draw(img)
    draw.text((0, 0), char, font=font, fill=255)

    # Преобразуем в черно-белый формат (1 бит на пиксель)
    threshold = 128
    img = img.point(lambda x: 255 if x > threshold else 0, mode='1')

    # Преобразуем в байты по строкам (каждая строка — массив байт)
    pixels = list(img.getdata())
    width, height = img.size
    bitmap = []

    for y in range(height):
        row = []
        for x in range(width):
            pixel = pixels[y * width + x]
            row.append(1 if pixel else 0)
        # Преобразуем биты в байты
        byte_row = []
        for i in range(0, len(row), 8):
            byte = 0
            for bit in row[i:i+8]:
                byte = (byte << 1) | bit
            byte_row.append(byte)
        bitmap.append(byte_row)

    return bitmap, width, height

def generate_font_bitmap(font_path, height):
    font = ImageFont.truetype(font_path, height)

    # Расширенный набор символов включая русские буквы
    chars = []
    
    # ASCII символы (32-126)
    for i in range(32, 127):
        chars.append(chr(i))
    
    # Русские буквы (заглавные и строчные)
    for i in range(ord('А'), ord('я') + 1):
        chars.append(chr(i))
    
    # Дополнительные символы
    additional_chars = ['Ё', 'ё']
    chars.extend(additional_chars)

    font_data = {}
    
    for char in chars:
        try:
            bitmap, width, height = char_to_bitmap(char, font, height)
            # Используем код символа как ключ
            font_data[ord(char)] = {
                'bitmap': bitmap,
                'width': width,
                'height': height,
                'char': char
            }
        except Exception as e:
            print(f"Ошибка при обработке символа '{char}': {e}")
            continue

    return font_data

def save_to_header_file(font_data, font_name, height):
    # Создаем имя файла
    safe_font_name = "".join(c for c in font_name if c.isalnum() or c in "._-")
    filename = f"font_{safe_font_name}_{height}.h"
    
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(f"// Font: {font_name}, Height: {height}px\n")
        f.write("// Generated by Python font rasterizer\n")
        f.write(f"// Total glyphs: {len(font_data)}\n\n")
        
        f.write("typedef struct {\n")
        f.write("    int code;\n")
        f.write("    int width;\n")
        f.write("    int height;\n")
        f.write("    const unsigned char* data;\n")
        f.write("} Glyph;\n\n")

        # Создаем общий массив данных
        f.write("static const unsigned char font_data[] = {\n")
        all_bytes = []
        offsets = []
        current_offset = 0
        
        # Сортируем по коду символа
        sorted_chars = sorted(font_data.keys())
        
        for char_code in sorted_chars:
            glyph = font_data[char_code]
            data = glyph['bitmap']
            flat_bytes = []
            for row in data:
                flat_bytes.extend(row)
            
            offsets.append(current_offset)
            all_bytes.extend(flat_bytes)
            current_offset += len(flat_bytes)
        
        # Записываем все байты
        for i, byte in enumerate(all_bytes):
            if i % 16 == 0:
                f.write("    ")
            f.write(f"0x{byte:02X}")
            if i < len(all_bytes) - 1:
                f.write(", ")
            if (i + 1) % 16 == 0:
                f.write("\n")
        if len(all_bytes) % 16 != 0:
            f.write("\n")
        f.write("};\n\n")

        # Создаем массив глифов с указателями на данные
        f.write(f"static Glyph glyphs[{len(font_data)}] = {{\n")
        for i, char_code in enumerate(sorted_chars):
            glyph = font_data[char_code]
            width = glyph['width']
            height = glyph['height']
            char_display = glyph['char']
            offset = offsets[i]
            size = sum(len(row) for row in glyph['bitmap'])
            
            # Экранируем специальные символы
            if char_display == '\\':
                char_display = '\\\\'
            elif char_display == '"':
                char_display = '\\"'
            elif char_display == "'":
                char_display = "\\'"
            
            f.write(f"    {{ {char_code}, {width}, {height}, &font_data[{offset}] }}, // '{char_display}'\n")
        f.write("};\n")

    print(f"Файл {filename} успешно создан!")
    print(f"Всего символов: {len(font_data)}")

# Пример использования
if __name__ == "__main__":
    font_path = "arial.ttf"  # Укажите путь к вашему .ttf файлу
    font_height = 30
    
    # Получаем имя шрифта без пути и расширения
    font_name = os.path.splitext(os.path.basename(font_path))[0]
    
    font_data = generate_font_bitmap(font_path, font_height)
    save_to_header_file(font_data, font_name, font_height)